//! Splatoon3 Ghost Drawer
//! 
//! Nintendo Switch Pro Controllerã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã—ã¦
//! Splatoon3ã§è‡ªå‹•çš„ã«ã‚¤ãƒ©ã‚¹ãƒˆã‚’æç”»ã™ã‚‹ã‚·ã‚¹ãƒ†ãƒ 

use splatoon3_ghost_drawer::domain::artwork::entities::{Artwork, ArtworkMetadata, Canvas, Dot};
use splatoon3_ghost_drawer::domain::artwork::value_objects::ImageFormat;
use splatoon3_ghost_drawer::domain::shared::value_objects::{Color, Coordinates};
use splatoon3_ghost_drawer::debug::{DebugConfig, init_logging, debug_helpers};
use splatoon3_ghost_drawer::application::use_cases::setup_usb_gadget::SetupUsbGadgetUseCase;
use splatoon3_ghost_drawer::infrastructure::hardware::{
    board_detector::LinuxBoardDetector,
    linux_usb_gadget::LinuxUsbGadgetManager,
    systemd_service::SystemdServiceManager,
};

use std::env;
use std::path::PathBuf;
use std::process;
use tracing::{info, error, debug, instrument};

// Web UIç”¨ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
use axum::{
    extract::ws::{Message, WebSocket, WebSocketUpgrade},
    extract::{Path, State},
    http::StatusCode,
    response::Response,
    routing::{get, post},
    Json, Router,
};
use tower::ServiceBuilder;
use tower_http::{
    cors::CorsLayer,
    services::ServeDir,
};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use serde::{Deserialize, Serialize};

/// ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®è¨­å®š
#[derive(Debug, Clone)]
pub struct AppConfig {
    pub verbose: bool,
}

impl Default for AppConfig {
    fn default() -> Self {
        Self {
            verbose: false,
        }
    }
}

/// CLIã‚³ãƒãƒ³ãƒ‰
#[derive(Debug, Clone)]
pub enum Command {
    /// ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤º
    Help,
    /// ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’è¡¨ç¤º
    Version,
    /// Web UIã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•
    Serve {
        port: Option<u16>,
        host: Option<String>,
    },
    /// USB Gadgetã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
    SetupGadget {
        force: bool,
    },
}

/// ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼
#[derive(Debug, thiserror::Error)]
pub enum AppError {
    #[error("Invalid command line arguments: {message}")]
    InvalidArgs { message: String },
    #[error("File not found: {path}")]
    FileNotFound { path: PathBuf },
    #[error("Invalid file format: {format}")]
    InvalidFormat { format: String },
    #[error("Processing error: {message}")]
    ProcessingError { message: String },
    #[error("Configuration error: {message}")]
    ConfigError { message: String },
    #[error("IO error: {source}")]
    IoError { #[from] source: std::io::Error },
}

/// CLIã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³
pub struct App {
    config: AppConfig,
}

impl App {
    /// æ–°ã—ã„ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆ
    pub fn new(config: AppConfig) -> Self {
        Self { config }
    }

    /// ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œ
    #[instrument(skip(self), fields(verbose = %self.config.verbose))]
    pub async fn run(&self, command: Command) -> Result<(), AppError> {
        info!("ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œé–‹å§‹");
        
        if self.config.verbose {
            debug!("å®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰: {:?}", command);
            debug!("è¨­å®š: {:?}", self.config);
        }

        let result = match command {
            Command::Help => {
                info!("ãƒ˜ãƒ«ãƒ—ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œ");
                self.show_help()
            },
            Command::Version => {
                info!("ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œ");
                self.show_version()
            },
            Command::Serve { ref port, ref host } => {
                info!(
                    port = ?port,
                    host = ?host,
                    "Web UIã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•"
                );
                self.start_web_server(port.unwrap_or(8080), host.clone().unwrap_or_else(|| "127.0.0.1".to_string())).await
            },
            Command::SetupGadget { force } => {
                info!(
                    force = %force,
                    "USB Gadgetã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œ"
                );
                self.setup_usb_gadget(force).await
            },
        };

        match &result {
            Ok(()) => info!("ã‚³ãƒãƒ³ãƒ‰ãŒæ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸ"),
            Err(e) => error!("ã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {}", e),
        }

        result
    }

    /// ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤º
    fn show_help(&self) -> Result<(), AppError> {
        println!("Splatoon3 Ghost Drawer v{}", env!("CARGO_PKG_VERSION"));
        println!("Nintendo Switch Pro Controllerã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã—ã¦ã‚¤ãƒ©ã‚¹ãƒˆã‚’è‡ªå‹•æç”»");
        println!();
        println!("ä½¿ç”¨æ–¹æ³•:");
        println!("  {} [ã‚ªãƒ—ã‚·ãƒ§ãƒ³] <ã‚³ãƒãƒ³ãƒ‰> [å¼•æ•°...]", env!("CARGO_PKG_NAME"));
        println!();
        println!("ã‚³ãƒãƒ³ãƒ‰:");
        println!("  serve                          Web UIã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹• (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 127.0.0.1:8080)");
        println!("  setup-gadget                   USB Gadgetã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—");
        println!("  help                           ã“ã®ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤º");
        println!("  version                        ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’è¡¨ç¤º");
        println!();
        println!("ã‚ªãƒ—ã‚·ãƒ§ãƒ³:");
        println!("  -v, --verbose                  è©³ç´°å‡ºåŠ›ã‚’æœ‰åŠ¹åŒ–");
        println!();
        println!("serve ã‚³ãƒãƒ³ãƒ‰ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³:");
        println!("  --port <ãƒãƒ¼ãƒˆ>                ã‚µãƒ¼ãƒãƒ¼ãƒãƒ¼ãƒˆ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 8080)");
        println!("  --host <ãƒ›ã‚¹ãƒˆ>                ãƒ›ã‚¹ãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 127.0.0.1)");
        println!();
        println!("setup-gadget ã‚³ãƒãƒ³ãƒ‰ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³:");
        println!("  --force                        æ—¢å­˜ã®è¨­å®šã‚’å¼·åˆ¶çš„ã«ä¸Šæ›¸ã");
        println!();
        println!("ä¾‹:");
        println!("  {} serve", env!("CARGO_PKG_NAME"));
        println!("  {} serve --port 8080 --host 0.0.0.0", env!("CARGO_PKG_NAME"));
        println!("  {} setup-gadget", env!("CARGO_PKG_NAME"));
        println!("  {} setup-gadget --force", env!("CARGO_PKG_NAME"));
        
        Ok(())
    }

    /// ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’è¡¨ç¤º
    fn show_version(&self) -> Result<(), AppError> {
        println!("{} {}", env!("CARGO_PKG_NAME"), env!("CARGO_PKG_VERSION"));
        println!("ä½œè€…: {}", env!("CARGO_PKG_AUTHORS"));
        println!("èª¬æ˜: {}", env!("CARGO_PKG_DESCRIPTION"));
        Ok(())
    }







    /// ã‚µãƒ³ãƒ—ãƒ«ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½œæˆ
    fn create_sample_canvas(&self) -> Canvas {
        let mut canvas = Canvas::new(100, 100);
        
        // ã‚µãƒ³ãƒ—ãƒ«ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½œæˆ
        for y in 0..100 {
            for x in 0..100 {
                let coord = Coordinates::new(x, y);
                let color = if (x + y) % 2 == 0 {
                    Color::new(255, 0, 0, 255) // èµ¤
                } else {
                    Color::new(0, 0, 255, 255) // é’
                };
                let dot = Dot::new(color, 255);
                let _ = canvas.set_dot(coord, dot);
            }
        }
        
        canvas
    }

    /// æç”»ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è¡¨ç¤º
    async fn show_painting_preview(&self, artwork: &Artwork, dots_per_second: f64) -> Result<(), AppError> {
        let drawable_dots = artwork.drawable_dots();
        let estimated_time = artwork.estimated_painting_time(dots_per_second);

        println!("  æç”»å¯èƒ½ãƒ‰ãƒƒãƒˆæ•°: {}", drawable_dots);
        println!("  æ¨å®šæç”»æ™‚é–“: {}ç§’", estimated_time);
        println!("  æç”»é€Ÿåº¦: {:.1} ãƒ‰ãƒƒãƒˆ/ç§’", dots_per_second);
        println!("  å®Œæˆåº¦: {:.1}%", artwork.completion_ratio() * 100.0);
        println!("  è¤‡é›‘åº¦: {:.3}", artwork.complexity_score());

        // æœ€åˆã®æ•°ãƒ‰ãƒƒãƒˆã®åº§æ¨™ã‚’è¡¨ç¤º
        let dots: Vec<_> = artwork.canvas.drawable_dots().into_iter().take(5).collect();
        if !dots.is_empty() {
            println!("  æœ€åˆã®æç”»ãƒ‰ãƒƒãƒˆ:");
            for (i, (coord, dot)) in dots.iter().enumerate() {
                println!("    {}. {} - {}", i + 1, coord, dot.color);
            }
            if artwork.canvas.drawable_dots().len() > 5 {
                println!("    ... ä»–{}å€‹", artwork.canvas.drawable_dots().len() - 5);
            }
        }

        Ok(())
    }

    /// æç”»ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
    async fn simulate_painting(&self, artwork: &Artwork, dots_per_second: f64) -> Result<(), AppError> {
        let drawable_dots = artwork.canvas.drawable_dots();
        let total_dots = drawable_dots.len();
        
        if total_dots == 0 {
            println!("æç”»ã™ã‚‹ãƒ‰ãƒƒãƒˆãŒã‚ã‚Šã¾ã›ã‚“");
            return Ok(());
        }

        let interval_ms = (1000.0 / dots_per_second) as u64;
        
        println!("æç”»é€²è¡Œä¸­:");
        for (i, (coord, _dot)) in drawable_dots.iter().enumerate() {
            let progress = ((i + 1) as f64 / total_dots as f64) * 100.0;
            
            if self.config.verbose {
                println!("  ãƒ‰ãƒƒãƒˆ {} ã‚’ {} ã«æç”»ä¸­... ({:.1}%)", i + 1, coord, progress);
            } else if i % 10 == 0 || i == total_dots - 1 {
                println!("  é€²æ—: {:.1}% ({}/{})", progress, i + 1, total_dots);
            }

            // æç”»ã®é…å»¶ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
            tokio::time::sleep(tokio::time::Duration::from_millis(interval_ms)).await;
        }

        Ok(())
    }

    /// USB Gadgetã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
    #[instrument(skip(self), fields(force = %force))]
    async fn setup_usb_gadget(&self, force: bool) -> Result<(), AppError> {
        info!("USB Gadgetã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’é–‹å§‹");

        // rootæ¨©é™ãƒã‚§ãƒƒã‚¯
        let euid = unsafe { libc::geteuid() };
        if euid != 0 {
            return Err(AppError::ProcessingError {
                message: "ã“ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã«ã¯rootæ¨©é™ãŒå¿…è¦ã§ã™ã€‚sudoã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚".to_string(),
            });
        }

        // ãƒªãƒã‚¸ãƒˆãƒªã‚’ä½œæˆ
        let board_repo = LinuxBoardDetector::new();
        let gadget_repo = LinuxUsbGadgetManager::new();
        let service_repo = SystemdServiceManager::new();

        // ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã‚’å®Ÿè¡Œ
        let use_case = SetupUsbGadgetUseCase::new(board_repo, gadget_repo, service_repo);
        let result = use_case.execute(force).await
            .map_err(|e| AppError::ProcessingError {
                message: format!("USB Gadgetã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã«å¤±æ•—ã—ã¾ã—ãŸ: {}", e),
            })?;

        // çµæœã‚’è¡¨ç¤º
        println!("âœ… USB Gadgetã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Œäº†");
        println!();
        println!("{}", result.summary());

        if result.reboot_required {
            println!();
            println!("âš ï¸  å†èµ·å‹•ãŒå¿…è¦ã§ã™ã€‚ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„:");
            println!("    sudo reboot");
        }

        Ok(())
    }

    /// Web UIã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•
    #[instrument(skip(self), fields(host = %host, port = %port))]
    async fn start_web_server(&self, port: u16, host: String) -> Result<(), AppError> {
        info!("Web UIã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•ä¸­");

        // å…±æœ‰çŠ¶æ…‹ã‚’ä½œæˆ
        let app_state = Arc::new(AppState {
            artworks: Arc::new(RwLock::new(HashMap::new())),
            config: self.config.clone(),
        });

        // ãƒ«ãƒ¼ã‚¿ãƒ¼ã‚’æ§‹ç¯‰
        let app = Router::new()
            // é™çš„ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆWeb UIï¼‰
            .nest_service("/", ServeDir::new("web"))
            // API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
            .route("/api/artworks", get(list_artworks).post(create_artwork_api))
            .route("/api/artworks/upload", post(upload_artwork_api))
            .route("/api/artworks/:id", get(get_artwork).delete(delete_artwork))
            .route("/api/artworks/:id/paint", post(paint_artwork_api))
            .route("/api/config", get(get_config_handler))
            .route("/api/system/info", get(get_system_info))
            .route("/api/hardware/status", get(get_hardware_status))
            // WebSocket ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼ˆãƒ­ã‚°ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ç”¨ï¼‰
            .route("/ws/logs", get(websocket_handler))
            // çŠ¶æ…‹ã‚’å…±æœ‰
            .with_state(app_state)
            // CORSè¨­å®š
            .layer(
                ServiceBuilder::new()
                    .layer(CorsLayer::permissive())
            );

        let addr = format!("{}:{}", host, port);
        info!(address = %addr, "Web UIã‚µãƒ¼ãƒãƒ¼ã‚’é–‹å§‹");

        println!("ğŸŒ Web UI ã‚µãƒ¼ãƒãƒ¼ãŒèµ·å‹•ã—ã¾ã—ãŸ");
        println!("   URL: http://{}", addr);
        println!("   Ctrl+C ã§åœæ­¢");

        // ã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•
        let listener = tokio::net::TcpListener::bind(&addr).await
            .map_err(|e| AppError::ProcessingError {
                message: format!("ã‚µãƒ¼ãƒãƒ¼ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ: {}", e),
            })?;

        axum::serve(listener, app).await
            .map_err(|e| AppError::ProcessingError {
                message: format!("ã‚µãƒ¼ãƒãƒ¼ã®å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {}", e),
            })?;

        Ok(())
    }
}

/// ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å…±æœ‰çŠ¶æ…‹
#[derive(Clone)]
struct AppState {
    artworks: Arc<RwLock<HashMap<String, Artwork>>>,
    config: AppConfig,
}

/// API: ã‚¢ãƒ¼ãƒˆãƒ¯ãƒ¼ã‚¯ä¸€è¦§å–å¾—
async fn list_artworks(State(state): State<Arc<AppState>>) -> Json<Vec<ArtworkSummary>> {
    let artworks = state.artworks.read().await;
    let summaries: Vec<ArtworkSummary> = artworks
        .values()
        .map(|artwork| ArtworkSummary {
            id: artwork.id.as_str().to_string(),
            name: artwork.metadata.name.clone(),
            format: artwork.original_format.clone(),
            canvas_size: format!("{}x{}", artwork.canvas.width, artwork.canvas.height),
            total_dots: artwork.total_dots(),
            drawable_dots: artwork.drawable_dots(),
            completion_ratio: artwork.completion_ratio(),
            created_at: artwork.created_at.epoch_millis,
            updated_at: artwork.updated_at.epoch_millis,
        })
        .collect();
    
    Json(summaries)
}

/// API: ã‚¢ãƒ¼ãƒˆãƒ¯ãƒ¼ã‚¯ä½œæˆ
async fn create_artwork_api(
    State(state): State<Arc<AppState>>,
    Json(request): Json<CreateArtworkRequest>,
) -> Result<Json<ArtworkResponse>, StatusCode> {
    info!(name = %request.name, "APIçµŒç”±ã§ã‚¢ãƒ¼ãƒˆãƒ¯ãƒ¼ã‚¯ã‚’ä½œæˆ");
    
    // ãƒ‰ãƒƒãƒˆãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½œæˆ
    let mut canvas = Canvas::new(request.width, request.height);
    
    // ãƒ‰ãƒƒãƒˆæ•°ã‚’ä¿å­˜
    let dot_count = request.dots.len();
    
    // ãƒ‰ãƒƒãƒˆãƒ‡ãƒ¼ã‚¿ã‚’è¨­å®š
    for dot_data in request.dots {
        let coord = Coordinates::new(dot_data.x, dot_data.y);
        let color = Color::new(
            dot_data.color.r,
            dot_data.color.g,
            dot_data.color.b,
            dot_data.color.a,
        );
        let dot = Dot::new(color, 255);
        let _ = canvas.set_dot(coord, dot);
    }
    
    let metadata = ArtworkMetadata::new(request.name.clone())
        .with_description(request.description.unwrap_or_else(|| "Web UIçµŒç”±ã§ä½œæˆï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ã§å‡¦ç†æ¸ˆã¿ï¼‰".to_string()));
    
    let artwork = Artwork::new(metadata, "png".to_string(), canvas);
    let artwork_id = artwork.id.as_str();
    
    // çŠ¶æ…‹ã«ä¿å­˜
    state.artworks.write().await.insert(artwork_id.to_string(), artwork.clone());
    
    info!(
        artwork_id = %artwork_id,
        width = %request.width,
        height = %request.height,
        dot_count = %dot_count,
        "ã‚¢ãƒ¼ãƒˆãƒ¯ãƒ¼ã‚¯ãŒAPIçµŒç”±ã§ä½œæˆã•ã‚Œã¾ã—ãŸ"
    );
    
    Ok(Json(ArtworkResponse {
        id: artwork_id.to_string(),
        message: format!("ã‚¢ãƒ¼ãƒˆãƒ¯ãƒ¼ã‚¯ãŒä½œæˆã•ã‚Œã¾ã—ãŸ: {}x{}, {}ãƒ‰ãƒƒãƒˆ", 
            request.width, 
            request.height, 
            dot_count
        ),
        artwork: None,  // ä¸€æ™‚çš„ã«artworkã®è©³ç´°ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³å•é¡Œã®ãŸã‚ï¼‰
    }))
}

/// API: ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
async fn upload_artwork_api(
    State(state): State<Arc<AppState>>,
    mut multipart: axum::extract::Multipart,
) -> Result<Json<ArtworkResponse>, StatusCode> {
    use std::io::Write;
    
    info!("ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚’é–‹å§‹");
    
    // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ç”¨ã®ãƒã‚¯ãƒ­
    macro_rules! handle_error {
        ($e:expr, $msg:expr) => {
            match $e {
                Ok(val) => val,
                Err(e) => {
                    error!("{}: {:?}", $msg, e);
                    return Err(StatusCode::INTERNAL_SERVER_ERROR);
                }
            }
        };
    }
    
    let mut name = "Untitled".to_string();
    let mut image_data: Option<Vec<u8>> = None;
    let mut original_filename: Option<String> = None;
    let mut threshold = 128u8;
    let mut dithering_type = "none".to_string();
    let mut dithering_strength = 50u8;
    let mut _output_format = "json".to_string();
    let mut _compression = 6u8;
    
    // æ–°ã—ã„ç”»åƒèª¿æ•´ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    let mut exposure = 0.0f32;
    let mut contrast = 0i8;
    let mut black_point = 0u8;
    let mut white_point = 255u8;
    let mut gamma = 1.0f32;
    let mut highlights = 0i8;
    let mut shadows = 0i8;
    let mut brightness = 0i8;
    let mut adaptive_threshold = false;
    let mut adaptive_block_size = 11u16;
    let mut adaptive_constant = 2i8;
    
    // ãƒãƒ«ãƒãƒ‘ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†
    while let Some(field) = multipart.next_field().await.map_err(|_| StatusCode::BAD_REQUEST)? {
        let field_name = field.name().unwrap_or("").to_string();
        
        match field_name.as_str() {
            "file" => {
                original_filename = field.file_name().map(|s| s.to_string());
                image_data = Some(field.bytes().await.map_err(|_| StatusCode::BAD_REQUEST)?.to_vec());
            },
            "name" => {
                name = field.text().await.map_err(|_| StatusCode::BAD_REQUEST)?;
            },
            "threshold" => {
                threshold = field.text().await.map_err(|_| StatusCode::BAD_REQUEST)?
                    .parse().unwrap_or(128);
            },
            "dithering_type" => {
                dithering_type = field.text().await.map_err(|_| StatusCode::BAD_REQUEST)?;
            },
            "dithering_strength" => {
                dithering_strength = field.text().await.map_err(|_| StatusCode::BAD_REQUEST)?
                    .parse().unwrap_or(50);
            },
            "output_format" => {
                _output_format = field.text().await.map_err(|_| StatusCode::BAD_REQUEST)?;
            },
            "compression" => {
                _compression = field.text().await.map_err(|_| StatusCode::BAD_REQUEST)?
                    .parse().unwrap_or(6);
            },
            // æ–°ã—ã„èª¿æ•´ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
            "exposure" => {
                exposure = field.text().await.map_err(|_| StatusCode::BAD_REQUEST)?
                    .parse().unwrap_or(0.0);
            },
            "contrast" => {
                contrast = field.text().await.map_err(|_| StatusCode::BAD_REQUEST)?
                    .parse().unwrap_or(0);
            },
            "black_point" => {
                black_point = field.text().await.map_err(|_| StatusCode::BAD_REQUEST)?
                    .parse().unwrap_or(0);
            },
            "white_point" => {
                white_point = field.text().await.map_err(|_| StatusCode::BAD_REQUEST)?
                    .parse().unwrap_or(255);
            },
            "gamma" => {
                gamma = field.text().await.map_err(|_| StatusCode::BAD_REQUEST)?
                    .parse().unwrap_or(1.0);
            },
            "highlights" => {
                highlights = field.text().await.map_err(|_| StatusCode::BAD_REQUEST)?
                    .parse().unwrap_or(0);
            },
            "shadows" => {
                shadows = field.text().await.map_err(|_| StatusCode::BAD_REQUEST)?
                    .parse().unwrap_or(0);
            },
            "brightness" => {
                brightness = field.text().await.map_err(|_| StatusCode::BAD_REQUEST)?
                    .parse().unwrap_or(0);
            },
            "adaptive_threshold" => {
                adaptive_threshold = field.text().await.map_err(|_| StatusCode::BAD_REQUEST)?
                    .parse().unwrap_or(false);
            },
            "adaptive_block_size" => {
                adaptive_block_size = field.text().await.map_err(|_| StatusCode::BAD_REQUEST)?
                    .parse().unwrap_or(11);
            },
            "adaptive_constant" => {
                adaptive_constant = field.text().await.map_err(|_| StatusCode::BAD_REQUEST)?
                    .parse().unwrap_or(2);
            },
            _ => {
                // æœªçŸ¥ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ç„¡è¦–
            }
        }
    }
    
    // ç”»åƒãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    let image_bytes = image_data.ok_or(StatusCode::BAD_REQUEST)?;
    
    info!(
        name = %name,
        filename = ?original_filename,
        image_size = %image_bytes.len(),
        threshold = %threshold,
        dithering_type = %dithering_type,
        "ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å‡¦ç†ã‚’é–‹å§‹"
    );
    
    // ç”»åƒãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’æ¨å®š
    let image_format = if let Some(filename) = &original_filename {
        ImageFormat::from_filename(filename).unwrap_or(ImageFormat::Png)
    } else {
        // ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æ¨å®šï¼ˆç°¡æ˜“ç‰ˆï¼‰
        if image_bytes.starts_with(&[0x89, 0x50, 0x4E, 0x47]) {
            ImageFormat::Png
        } else if image_bytes.starts_with(&[0xFF, 0xD8, 0xFF]) {
            ImageFormat::Jpeg
        } else {
            ImageFormat::Png
        }
    };
    
    // ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯ç”»åƒå‡¦ç†ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨ï¼‰
    let temp_dir = std::env::temp_dir();
    let temp_file = temp_dir.join(format!("upload_{}.{}", uuid::Uuid::new_v4(), image_format.extension()));
    
    {
        let mut file = handle_error!(
            std::fs::File::create(&temp_file),
            "ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã®ä½œæˆã«å¤±æ•—"
        );
        handle_error!(
            file.write_all(&image_bytes),
            "ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®æ›¸ãè¾¼ã¿ã«å¤±æ•—"
        );
    }
    
    // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
    let mut metadata = ArtworkMetadata::new(name.clone())
        .with_description(format!("Web UIçµŒç”±ã§ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰: {}", original_filename.as_ref().unwrap_or(&"unknown".to_string())));
    
    if let Some(filename) = &original_filename {
        metadata.original_filename = Some(filename.clone());
    }
    metadata.file_size = image_bytes.len() as u64;
    metadata.checksum = format!("{:x}", md5::compute(&image_bytes));
    
    // ç”»åƒèª¿æ•´ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
    let adjustments = splatoon3_ghost_drawer::domain::artwork::value_objects::ImageAdjustments {
        exposure,
        contrast,
        black_point,
        white_point,
        gamma,
        highlights,
        shadows,
        brightness,
        threshold,
        adaptive_threshold,
        adaptive_block_size,
        adaptive_constant,
    };
    
    // ã‚µãƒ³ãƒ—ãƒ«ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½œæˆï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯ç”»åƒã‚’è§£æã—ã¦å¤‰æ›ï¼‰
    let canvas = create_processed_canvas(&image_bytes, &adjustments, &dithering_type, dithering_strength);
    
    // ã‚¢ãƒ¼ãƒˆãƒ¯ãƒ¼ã‚¯ã‚’ä½œæˆ
    let artwork = Artwork::new(metadata, image_format.extension().to_string(), canvas);
    let artwork_id = artwork.id.as_str();
    
    // çŠ¶æ…‹ã«ä¿å­˜
    state.artworks.write().await.insert(artwork_id.to_string(), artwork.clone());
    
    // ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤
    let _ = std::fs::remove_file(temp_file);
    
    info!(
        artwork_id = %artwork_id,
        name = %name,
        format = %image_format,
        canvas_size = format!("{}x{}", artwork.canvas.width, artwork.canvas.height),
        total_dots = %artwork.total_dots(),
        drawable_dots = %artwork.drawable_dots(),
        "ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãŒå®Œäº†ã—ã¾ã—ãŸ"
    );
    
    Ok(Json(ArtworkResponse {
        id: artwork_id.to_string(),
        message: format!("ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã¨å¤‰æ›ãŒå®Œäº†ã—ã¾ã—ãŸ: {} ({}x{})", 
            name, 
            artwork.canvas.width, 
            artwork.canvas.height
        ),
        artwork: None,  // ä¸€æ™‚çš„ã«artworkã®è©³ç´°ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³å•é¡Œã®ãŸã‚ï¼‰
    }))
}

/// API: ã‚¢ãƒ¼ãƒˆãƒ¯ãƒ¼ã‚¯å–å¾—
async fn get_artwork(
    State(state): State<Arc<AppState>>,
    Path(id): Path<String>,
) -> Result<Json<Artwork>, StatusCode> {
    let artworks = state.artworks.read().await;
    match artworks.get(&id) {
        Some(artwork) => Ok(Json(artwork.clone())),
        None => Err(StatusCode::NOT_FOUND),
    }
}

/// API: ã‚¢ãƒ¼ãƒˆãƒ¯ãƒ¼ã‚¯å‰Šé™¤
async fn delete_artwork(
    State(state): State<Arc<AppState>>,
    Path(id): Path<String>,
) -> Result<Json<ApiResponse>, StatusCode> {
    let mut artworks = state.artworks.write().await;
    match artworks.remove(&id) {
        Some(_) => {
            info!(artwork_id = %id, "ã‚¢ãƒ¼ãƒˆãƒ¯ãƒ¼ã‚¯ãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸ");
            Ok(Json(ApiResponse {
                success: true,
                message: "ã‚¢ãƒ¼ãƒˆãƒ¯ãƒ¼ã‚¯ãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸ".to_string(),
            }))
        },
        None => Err(StatusCode::NOT_FOUND),
    }
}

/// API: ã‚¢ãƒ¼ãƒˆãƒ¯ãƒ¼ã‚¯æç”»
async fn paint_artwork_api(
    State(state): State<Arc<AppState>>,
    Path(id): Path<String>,
    Json(request): Json<PaintRequest>,
) -> Result<Json<ApiResponse>, StatusCode> {
    // ã‚¢ãƒ¼ãƒˆãƒ¯ãƒ¼ã‚¯ã®å–å¾—ã¨æ‰€æœ‰æ¨©ã®ç§»å‹•
    let artwork = {
        let mut artworks = state.artworks.write().await;
        match artworks.remove(&id) {
            Some(artwork) => artwork,
            None => return Err(StatusCode::NOT_FOUND),
        }
    };
    
    info!(
        artwork_id = %id,
        speed = %request.speed.unwrap_or(2.0),
        preview = %request.preview.unwrap_or(false),
        "APIçµŒç”±ã§æç”»ã‚’é–‹å§‹"
    );
    
    // æç”»ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯æç”»å‡¦ç†ã‚’å®Ÿè¡Œï¼‰
    let speed = request.speed.unwrap_or(2.0);
    let estimated_time = artwork.estimated_painting_time(speed);
    let drawable_dots = artwork.drawable_dots();
    
    // æç”»å‡¦ç†ã‚’ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§å®Ÿè¡Œ
    let id_clone = id.clone();
    tokio::spawn(async move {
        info!(
            artwork_id = %id_clone,
            dot_count = %drawable_dots,
            "æç”»å‡¦ç†ã‚’é–‹å§‹ã—ã¾ã—ãŸ"
        );
        
        // å®Ÿéš›ã®æç”»å‡¦ç†ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
        tokio::time::sleep(tokio::time::Duration::from_secs(estimated_time)).await;
        
        info!(
            artwork_id = %id_clone,
            "æç”»ãŒå®Œäº†ã—ã¾ã—ãŸã€‚ã‚¢ãƒ¼ãƒˆãƒ¯ãƒ¼ã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’ç ´æ£„ã—ã¾ã™"
        );
        
        // æç”»å®Œäº†å¾Œã€ãƒ‡ãƒ¼ã‚¿ã¯è‡ªå‹•çš„ã«ç ´æ£„ã•ã‚Œã‚‹ï¼ˆã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹ãŸã‚ï¼‰
    });
    
    Ok(Json(ApiResponse {
        success: true,
        message: format!("æç”»ã‚’é–‹å§‹ã—ã¾ã—ãŸï¼ˆæ¨å®šæ™‚é–“: {}ç§’ï¼‰ã€‚å®Œäº†å¾Œã€ãƒ‡ãƒ¼ã‚¿ã¯è‡ªå‹•çš„ã«ç ´æ£„ã•ã‚Œã¾ã™ã€‚", estimated_time),
    }))
}

/// API: è¨­å®šå–å¾—
async fn get_config_handler(State(state): State<Arc<AppState>>) -> Json<serde_json::Value> {
    Json(serde_json::json!({
        "verbose": state.config.verbose,
    }))
}

/// API: ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±å–å¾—
async fn get_system_info() -> Json<SystemInfo> {
    Json(SystemInfo {
        version: env!("CARGO_PKG_VERSION").to_string(),
        rust_version: env!("CARGO_PKG_RUST_VERSION").to_string(),
        os: std::env::consts::OS.to_string(),
        arch: std::env::consts::ARCH.to_string(),
        uptime_seconds: 0, // TODO: å®Ÿéš›ã®ç¨¼åƒæ™‚é–“ã‚’å®Ÿè£…
    })
}

/// API: ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢æ¥ç¶šçŠ¶æ…‹å–å¾—
async fn get_hardware_status() -> Json<HardwareStatus> {
    let nintendo_switch_connected = check_nintendo_switch_connection().await;
    let usb_otg_available = check_usb_otg_availability();
    let hid_device_available = check_hid_device_availability();
    
    Json(HardwareStatus {
        nintendo_switch_connected,
        usb_otg_available,
        hid_device_available,
        last_check: chrono::Utc::now().to_rfc3339(),
        details: get_hardware_details(),
    })
}

/// Nintendo Switchã¨ã®æ¥ç¶šçŠ¶æ…‹ã‚’ç¢ºèª
async fn check_nintendo_switch_connection() -> bool {
    // HIDãƒ‡ãƒã‚¤ã‚¹ãŒå­˜åœ¨ã—ã€ã‹ã¤ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªæ¥ç¶šãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    if !check_hid_device_availability() {
        return false;
    }
    
    // USB Gadgetã®çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯
    if let Ok(udc_content) = std::fs::read_to_string("/sys/kernel/config/usb_gadget/nintendo_controller/UDC") {
        return !udc_content.trim().is_empty();
    }
    
    false
}

/// USB OTGã®åˆ©ç”¨å¯èƒ½æ€§ã‚’ãƒã‚§ãƒƒã‚¯
fn check_usb_otg_availability() -> bool {
    // dwc2ãƒ‰ãƒ©ã‚¤ãƒãƒ¼ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    if let Ok(modules) = std::fs::read_to_string("/proc/modules") {
        if modules.contains("dwc2") {
            return true;
        }
    }
    
    // USB Gadgetè¨­å®šãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å­˜åœ¨ã‚’ãƒã‚§ãƒƒã‚¯
    std::path::Path::new("/sys/kernel/config/usb_gadget").exists()
}

/// HIDãƒ‡ãƒã‚¤ã‚¹ã®åˆ©ç”¨å¯èƒ½æ€§ã‚’ãƒã‚§ãƒƒã‚¯
fn check_hid_device_availability() -> bool {
    // /dev/hidg0 ãªã©ã®HIDãƒ‡ãƒã‚¤ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ã‚’ãƒã‚§ãƒƒã‚¯
    for i in 0..10 {
        let hid_path = format!("/dev/hidg{}", i);
        if std::path::Path::new(&hid_path).exists() {
            return true;
        }
    }
    false
}

/// ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã®è©³ç´°æƒ…å ±ã‚’å–å¾—
fn get_hardware_details() -> HardwareDetails {
    let mut usb_gadgets = Vec::new();
    let mut hid_devices = Vec::new();
    
    // USB Gadgetã®ä¸€è¦§ã‚’å–å¾—
    if let Ok(entries) = std::fs::read_dir("/sys/kernel/config/usb_gadget") {
        for entry in entries.flatten() {
            if let Some(name) = entry.file_name().to_str() {
                usb_gadgets.push(name.to_string());
            }
        }
    }
    
    // HIDãƒ‡ãƒã‚¤ã‚¹ã®ä¸€è¦§ã‚’å–å¾—
    for i in 0..10 {
        let hid_path = format!("/dev/hidg{}", i);
        if std::path::Path::new(&hid_path).exists() {
            hid_devices.push(hid_path);
        }
    }
    
    // ãƒœãƒ¼ãƒ‰ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œå‡º
    let board_model = detect_board_model();
    
    HardwareDetails {
        board_model,
        usb_gadgets,
        hid_devices,
        dwc2_loaded: check_dwc2_module(),
        libcomposite_loaded: check_libcomposite_module(),
    }
}

/// ãƒœãƒ¼ãƒ‰ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œå‡º
fn detect_board_model() -> String {
    if let Ok(cpuinfo) = std::fs::read_to_string("/proc/cpuinfo") {
        if cpuinfo.contains("Orange Pi Zero 2W") || cpuinfo.contains("sun50iw9") {
            return "Orange Pi Zero 2W".to_string();
        } else if cpuinfo.contains("Raspberry Pi Zero 2") {
            return "Raspberry Pi Zero 2W".to_string();
        } else if cpuinfo.contains("Raspberry Pi Zero") {
            return "Raspberry Pi Zero W".to_string();
        }
    }
    "Unknown".to_string()
}

/// dwc2ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®èª­ã¿è¾¼ã¿çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯
fn check_dwc2_module() -> bool {
    if let Ok(modules) = std::fs::read_to_string("/proc/modules") {
        return modules.contains("dwc2");
    }
    false
}

/// libcompositeãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®èª­ã¿è¾¼ã¿çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯
fn check_libcomposite_module() -> bool {
    if let Ok(modules) = std::fs::read_to_string("/proc/modules") {
        return modules.contains("libcomposite");
    }
    false
}

/// WebSocket ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ï¼ˆãƒ­ã‚°ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ç”¨ï¼‰
async fn websocket_handler(ws: WebSocketUpgrade) -> Response {
    ws.on_upgrade(handle_websocket)
}

/// WebSocket æ¥ç¶šå‡¦ç†
async fn handle_websocket(mut socket: WebSocket) {
    info!("WebSocketæ¥ç¶šãŒç¢ºç«‹ã•ã‚Œã¾ã—ãŸ");
    
    // ã‚¦ã‚§ãƒ«ã‚«ãƒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
    let welcome_msg = serde_json::json!({
        "timestamp": chrono::Utc::now().to_rfc3339(),
        "level": "INFO",
        "message": "ãƒ­ã‚°ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸ",
        "target": "websocket",
        "fields": {},
        "span": null
    });
    
    if socket.send(Message::Text(welcome_msg.to_string())).await.is_err() {
        return;
    }
    
    // æ¥ç¶šã‚’ç¶­æŒï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯ãƒ­ã‚°ã‚’ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ï¼‰
    loop {
        tokio::time::sleep(tokio::time::Duration::from_secs(30)).await;
        
        let heartbeat = serde_json::json!({
            "timestamp": chrono::Utc::now().to_rfc3339(),
            "level": "DEBUG",
            "message": "WebSocket heartbeat",
            "target": "websocket",
            "fields": {},
            "span": null
        });
        
        if socket.send(Message::Text(heartbeat.to_string())).await.is_err() {
            break;
        }
    }
    
    info!("WebSocketæ¥ç¶šãŒçµ‚äº†ã—ã¾ã—ãŸ");
}

/// ç”»åƒãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†ã—ã¦ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½œæˆ
fn create_processed_canvas(
    image_bytes: &[u8], 
    adjustments: &splatoon3_ghost_drawer::domain::artwork::value_objects::ImageAdjustments,
    dithering_type: &str, 
    dithering_strength: u8
) -> Canvas {
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ç”»åƒå‡¦ç†ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨
    // ã“ã“ã§ã¯ã‚µãƒ³ãƒ—ãƒ«ã¨ã—ã¦ç°¡å˜ãªå‡¦ç†ã‚’è¡Œã†
    
    let width = 320u16;
    let height = 120u16;  // Splatoon3æ¨™æº–è§£åƒåº¦
    let mut canvas = Canvas::new(width, height);
    
    // ç”»åƒã‚µã‚¤ã‚ºã«åŸºã¥ã„ã¦ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç”Ÿæˆ
    let pattern_scale = (image_bytes.len() as f32 / 10000.0).min(2.0).max(0.5);
    
    for y in 0..height {
        for x in 0..width {
            let coord = Coordinates::new(x, y);
            
            // ç”»åƒãƒ‡ãƒ¼ã‚¿ã®ãƒãƒƒã‚·ãƒ¥å€¤ã‚’ä½¿ç”¨ã—ã¦ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç”Ÿæˆ
            let hash_input = format!("{}-{}-{}", x, y, image_bytes.len());
            let hash = md5::compute(hash_input.as_bytes());
            let hash_value = hash[0] as u16;
            
            // é–¾å€¤å‡¦ç†ï¼ˆèª¿æ•´ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é©ç”¨ï¼‰
            let intensity = ((hash_value as f32 * pattern_scale) as u8).min(255);
            let is_black = intensity < adjustments.threshold;
            
            // ãƒ‡ã‚£ã‚¶ãƒªãƒ³ã‚°å‡¦ç†
            let final_color = match dithering_type {
                "floyd_steinberg" => {
                    // ãƒ•ãƒ­ã‚¤ãƒ‰ãƒ»ã‚¹ã‚¿ã‚¤ãƒ³ãƒãƒ¼ã‚°ãƒ»ãƒ‡ã‚£ã‚¶ãƒªãƒ³ã‚°ï¼ˆç°¡æ˜“ç‰ˆï¼‰
                    let error = (intensity as i16 - if is_black { 0 } else { 255 }) * dithering_strength as i16 / 100;
                    let adjusted = (intensity as i16 + error / 4).max(0).min(255) as u8;
                    if adjusted < adjustments.threshold { Color::new(0, 0, 0, 255) } else { Color::new(255, 255, 255, 255) }
                },
                "ordered" => {
                    // çµ„ç¹”åŒ–ãƒ‡ã‚£ã‚¶ãƒªãƒ³ã‚°ï¼ˆç°¡æ˜“ç‰ˆï¼‰
                    let pattern = ((x % 4) + (y % 4) * 4) as u8 * 16;
                    let adjusted = intensity.saturating_add(pattern / 4);
                    if adjusted < adjustments.threshold { Color::new(0, 0, 0, 255) } else { Color::new(255, 255, 255, 255) }
                },
                _ => {
                    // ãƒ‡ã‚£ã‚¶ãƒªãƒ³ã‚°ãªã—
                    if is_black { Color::new(0, 0, 0, 255) } else { Color::new(255, 255, 255, 255) }
                }
                            };
                
                let dot = Dot::new(final_color, 255);
                let _ = canvas.set_dot(coord, dot);
        }
    }
    
    canvas
}

// API ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‹å®šç¾©
#[derive(Serialize, Deserialize)]
struct ArtworkSummary {
    id: String,
    name: String,
    format: String,
    canvas_size: String,
    total_dots: usize,
    drawable_dots: usize,
    completion_ratio: f64,
    created_at: u64,
    updated_at: u64,
}

#[derive(Serialize, Deserialize)]
struct CreateArtworkRequest {
    name: String,
    description: Option<String>,
    format: Option<String>,
    width: u16,
    height: u16,
    dots: Vec<DotData>,
}

#[derive(Serialize, Deserialize)]
struct DotData {
    x: u16,
    y: u16,
    color: ColorData,
}

#[derive(Serialize, Deserialize)]
struct ColorData {
    r: u8,
    g: u8,
    b: u8,
    a: u8,
}

#[derive(Serialize, Deserialize)]
struct ArtworkResponse {
    id: String,
    message: String,
    artwork: Option<Artwork>,
}

#[derive(Serialize, Deserialize)]
struct PaintRequest {
    speed: Option<f64>,
    preview: Option<bool>,
}

#[derive(Serialize, Deserialize)]
struct ApiResponse {
    success: bool,
    message: String,
}

#[derive(Serialize, Deserialize)]
struct SystemInfo {
    version: String,
    rust_version: String,
    os: String,
    arch: String,
    uptime_seconds: u64,
}

#[derive(Serialize, Deserialize)]
struct HardwareStatus {
    nintendo_switch_connected: bool,
    usb_otg_available: bool,
    hid_device_available: bool,
    last_check: String,
    details: HardwareDetails,
}

#[derive(Serialize, Deserialize)]
struct HardwareDetails {
    board_model: String,
    usb_gadgets: Vec<String>,
    hid_devices: Vec<String>,
    dwc2_loaded: bool,
    libcomposite_loaded: bool,
}

/// ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã‚’è§£æ
fn parse_args() -> Result<(AppConfig, Command), AppError> {
    let args: Vec<String> = env::args().collect();
    
    if args.len() < 2 {
        return Ok((AppConfig::default(), Command::Help));
    }

    let mut config = AppConfig::default();
    let mut command_args = Vec::new();
    let mut i = 1;

    // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è§£æ
    while i < args.len() {
        match args[i].as_str() {
            "-v" | "--verbose" => {
                config.verbose = true;
                i += 1;
            },
            arg if arg.starts_with('-') && !arg.starts_with("--") => {
                return Err(AppError::InvalidArgs {
                    message: format!("Unknown option: {}", arg),
                });
            },
            _ => {
                // ã‚³ãƒãƒ³ãƒ‰å¼•æ•°ã®é–‹å§‹
                command_args.extend_from_slice(&args[i..]);
                break;
            }
        }
    }

    // ã‚³ãƒãƒ³ãƒ‰ã‚’è§£æ
    let command = if command_args.is_empty() {
        Command::Help
    } else {
        match command_args[0].as_str() {
            "help" | "-h" | "--help" => Command::Help,
            "version" | "-V" | "--version" => Command::Version,
            "serve" => {
                let mut port = None;
                let mut host = None;
                
                // ãƒãƒ¼ãƒˆã¨ãƒ›ã‚¹ãƒˆã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è§£æ
                let mut i = 1;
                while i < command_args.len() {
                    match command_args[i].as_str() {
                        "--port" => {
                            if i + 1 < command_args.len() {
                                port = Some(command_args[i + 1].parse().map_err(|_| {
                                    AppError::InvalidArgs {
                                        message: "Invalid port number".to_string(),
                                    }
                                })?);
                                i += 2;
                            } else {
                                return Err(AppError::InvalidArgs {
                                    message: "--port requires a value".to_string(),
                                });
                            }
                        },
                        "--host" => {
                            if i + 1 < command_args.len() {
                                host = Some(command_args[i + 1].clone());
                                i += 2;
                            } else {
                                return Err(AppError::InvalidArgs {
                                    message: "--host requires a value".to_string(),
                                });
                            }
                        },
                        _ => i += 1,
                    }
                }
                
                Command::Serve { port, host }
            },
            "setup-gadget" => {
                let force = command_args.contains(&"--force".to_string());
                Command::SetupGadget { force }
            },
            unknown => {
                return Err(AppError::InvalidArgs {
                    message: format!("Unknown command: {}", unknown),
                });
            }
        }
    };

    Ok((config, command))
}

/// ãƒ¡ã‚¤ãƒ³é–¢æ•°
#[tokio::main]
async fn main() {
    // ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–
    let debug_config = if env::var("RUST_ENV").unwrap_or_else(|_| "development".to_string()) == "production" {
        DebugConfig::production()
    } else {
        DebugConfig::development()
    };
    
    if let Err(e) = init_logging(&debug_config) {
        eprintln!("ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ: {}", e);
        process::exit(1);
    }

    // ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±ã‚’ãƒ­ã‚°ã«å‡ºåŠ›
    debug_helpers::log_system_info();

    // ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã‚’è§£æ
    let (config, command) = match parse_args() {
        Ok((config, command)) => {
            info!("ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã‚’è§£æã—ã¾ã—ãŸ: {:?}", command);
            (config, command)
        },
        Err(e) => {
            error!("ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ: {}", e);
            eprintln!("ã‚¨ãƒ©ãƒ¼: {}", e);
            eprintln!("ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤ºã™ã‚‹ã«ã¯ 'help' ã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„");
            process::exit(1);
        }
    };

    // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œ
    let app = App::new(config);
    if let Err(e) = app.run(command).await {
        debug_helpers::log_error_details(&e, "ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ");
        error!("ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸ: {}", e);
        eprintln!("ã‚¨ãƒ©ãƒ¼: {}", e);
        process::exit(1);
    }

    info!("ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒæ­£å¸¸ã«çµ‚äº†ã—ã¾ã—ãŸ");
}
